#summary sqliteBot homepage

see also <br/>
[DevelopmentIdeas]
[MapGenerator]

document http://docs.google.com/Doc?docid=0AUGdvmaCDgbOZGcyYnozbjZfNTdma2g3cWNnZw&hl=en <br/>
powerpoint http://docs.google.com/present/view?id=dg2bz3n6_51dh2xbpcj <br/>
youtube http://www.youtube.com/watch?v=XWkXcTIPkpM

----
*Update September 9, 2009*

from http://www.botprize.org/

_The 2009 BotPrize Contest has been decided!_

_None of the bots was able to fool enough judges to take the major prize. But all the bots fooled at least one of the judges._

_The most human-like bot was sqlitebot by Jeremy Cothran. The joint runners up were anubot from Chris Pelling and ICE-2009 from the team from Ritsumeikan Univerisity, Japan. Jeremy and Chris are both new entrants, and the ICE team were also runners up in 2008._

My thanks to all those organizing and participating in the botprize 2009 contest.  I really appreciate the infrastructure, work and ideas of those contributing.

*So what's next?*  I'm sure there are lots of ideas on how to better improve the bots, but how to do that more systematically in a more tools/framework environment?  What *open source AI tools/frameworks*(including or in addition to the Gamebot/Pogamut) could the community develop/utilize to better automatically generate/debug/tune code from behavior/planner schema and more easily mix and match bot intelligence/behavioral features?  How do AI projects more effectively build on existing base knowledge towards more novel/inclusive behaviors,features and combinations?

An approach that comes to mind is working with UML diagrams as a general model abstraction which helps inform/populate underlying toolsets.  Not sure what the AI parallel approaches are in this regard.

The approach which I'll probably start next is to refactor the existing code as a [http://aigamedev.com/open/articles/bt-overview/ behavioral tree(BT)] using the pogamut [http://www.cs.bath.ac.uk/~jjb/web/posh.html POSH] subproject to describe the behavior tree in a .lap file.  Will probably also take a look at the earlier [http://artemis.ms.mff.cuni.cz/pogamut/tiki-index.php?page=POSH+GUI POSH GUI project] for displaying the .lap content.  Using the .lap file should help better abstract the AI design from its implementation to serve as a better working example for reuse in a variety of other AI and implementation contexts.

Another development aspect would be to develop a [http://racc.bots-united.com/tutorial-navmesh.html navmesh] directly from the map geometry via [http://wiki.beyondunreal.com/Legacy:T3D_File exporting the .t3d file] using the unreal editor and analyzing/reprocessing this file to include the automatically generated pathnodes/navpoints within the map and database files.  Map navmeshes developed automatically from the geometry in this way could also be coded for certain point or area attributes like cover,jumping,etc.  _Update: Unreal includes an existing console command for auto-generating pathnodes which is not recommended highly due to performance issues relating to the number of pathnodes, so might focus instead initially on analysis/feature extraction from existing pathnodes versus the map geometry._

Links of immediate interest - AI and gameplay tools/analysis are interlinked<br/> 
Unreal Visualization Toolkit http://digitalfootprints.co.uk/?page_id=9 <br/>
Visualizing Competitive Behaviors http://www.cs.virginia.edu/~gfx/pubs/lithium/

So more questions than answers here - if folks have links or ideas I can list them on this wiki for consideration.  I've started a partial list [http://code.google.com/p/sqlitebot/wiki/sqlitebotHome#Links here]

If folks are interested in the very latest version of the sqlitebot code, contributing to this project or AI/gameplay consulting/contracting or just a friendly word/comment, send me an email(jeremy.cothran@gmail.com).  I have also setup a [http://groups.google.com/group/sqlitebot google group discussion list] and [http://twitter.com/sqlitebot twitter feed].

----
*Interested in some UT2004 bot AI cage match action?*  email me(jeremy.cothran@gmail.com) your Pogamut based bot AI .jar file (including launch file) with bot skill level set at level 4 and I can run a best out of 3 deathmatch on level 'Crash' or some other level to be discussed.  Video results and discussion posted to youtube.  see [http://code.google.com/p/botmatch/ botmatch ]
----
*Table of Contents*
<wiki:toc max_depth="6">

= Introduction =

Many gaming AI's utilize behavioral decision trees, few incorporate locational/situational memory as logged say via a lightweight relational database like sqlite

This is an open source project which is trying to utilize a [http://sqlite.org sqlite] database to store gaming bot location and situational awareness to help better adapt gaming AI(Artificial Intelligence) and behaviors for games.

The project is starting utilizing the [http://artemis.ms.mff.cuni.cz/pogamut/tiki-index.php Pogamut] Java/NetBeans based project code.  This bot was also selected as a finalist in the [http://www.botprize.org/teams.html 2009 botprize contest] with finals being held in September 2009.

My(jeremy.cothran@gmail.com) development background is more with Perl so I'll be learning some Java and NetBeans as I go.  I've played with Unrealscript (similar to Java) in the past and familiar with some of the Unreal Tournament 2004 bot functions but will be learning more about that also as I go.

The initial goals of the project are:

  # Java - figure out how to properly break my files up so functions and variables are scoped properly
  # begin modifying bot behavior in interesting ways based on sqlite database lookups(locational/situational memory)

Initially I'm looking for help with the above two goals - writing Java classes/functions/packages appropriately split up across files in the project - figuring some interesting behaviors to tackle - and being familiar enough with the standing bot functions to leverage those without rewriting them.

The initial sqlite table would be structured something like:

{{{
CREATE TABLE obs_type (
    row_id integer PRIMARY KEY,
    row_entry_date text,
    map_id int,
    location text,
    status int
);
}}}

with *location* reflecting the bots map(*map_id*) location when a specified *status* (made a kill, was killed,etc) at a specified time(*row_entry_date*).

Tracking those things initially should allow a bot to begin selecting better and worse map locations for optimal scoring or begin time-based tactics or behaviors relating to location and predicted location of opponents.

= Easy install (jar file) =

Just download/unzip this [http://sqlitebot.googlecode.com/files/sqlitebot.zip zip file] to  'c:\sqlitebot' folder(includes necessary .jar and \lib) and run the following command. *The sqlite dbpath uses an absolute path of c:\sqlitebot\sample.db' so the sample.db file must live there for the script to work.* Bot shows up using bot launcher as 'Player_Jeremy' for now.

{{{java.exe -jar c:\sqlitebot\sqlitebot.jar}}}

= Installing sqlite driver = 

To get going with sqlite and java I utilized the .jar at http://www.zentus.com/sqlitejdbc/ , [http://sqlitebot.googlecode.com/files/sqlitejdbc-v056.jar .jar file here] although the connection was refused by the program until I added the .jar file to both the netbeans classpath and the location C:\Program Files\Java\jre6\lib\ext\sqlitejdbc-v056.jar (see http://www.newsvoter.com/blog/TechNotes/java-lang-ClassNotFoundException--org-sqlite-JDBC.html )

I'd like to try the Xerial sqlite .jar http://www.xerial.org/trac/Xerial/wiki/SQLiteJDBC as it should be faster executing, but the zentus seems to work for the time being.

To establish the 'sqlite' driver in the netbeans IDE, goto Window->Services, then from the pop-up window select Databases->Drivers, then right click on Drivers to add a 'New Driver' and on the pop-up after that click the 'Add' button and path to the location of the sqlite jar file (for me this is C:\Program Files\Java\jre6\lib\ext\sqlitejdbc-v056.jar )

Then click the 'Find' button for 'Driver Class' which should populate the field with 'org.sqlite.JDBC'

For the driver 'Name' field enter 'sqlite' and *be sure it is all lower case and spelled the same* for it to work with the existing code example.  If the name/case is different than 'sqlite' you may need to correct it in your *project.properties file* to get it to stop looking at the wrong/bad example for the sqlite driver.

To add the sqlite driver to the netbeans libraries, from the netbeans IDE menu choose Tools->Libraries  On the pop-up window under 'Class Libraries' choose 'New Library'and on the subsequent pop-up name the library 'sqlite' (all lower case).  Then on the following options use the 'Add JAR/Folder' button to navigate to the sqlite jar file (path is C:\Program Files\Java\jre6\lib\ext\sqlitejdbc-v056.jar )

To add the sqlite driver to the project library, under the Project->Libraries folder, choose 'Add Library' and choose the sqlite library.

== Working with sql, sqlite database ==

Download the sqlite3 windows executable .exe (in a [http://www.sqlite.org/sqlite-3_6_15.zip zip file]) from the [http://www.sqlite.org/download.html sqlite download page].

My current path to the database is 
{{{c:\progra~1\pogamu~1\PogamutPlatform\projects\AdvancedBot\src\advancedbot\sample.db}}}

To open this database and get a sqlite command prompt I issue the following command from a command window.

{{{c:\Documents and Settings\logan\Desktop>sqlite3 c:\progra~1\pogamu~1\PogamutPlatform\projects\AdvancedBot\src\advancedbot\sample.db}}}

Notice also that the above database path is required or should be changed in the java functions which access the database(Main.java).

== Basic SQL commands ==

From the sqlite command prompt, to see a list of tables<br/>
{{{.tables}}}

The only table on the database is 'obs', to see the schema<br/>
{{{.schema obs}}}

To see a listing of rows on the table<br/>
{{{select * from obs;}}}

To certain rows on the table<br/>
{{{delete from obs where row_id > 3;}}}

To delete all rows from the table<br/>
{{{delete from obs;}}}

----

= google group discussion =

http://groups.google.com/group/sqlitebot

= Subversion =

For notes on using [http://code.google.com/p/sqlitebot/source/browse/#svn/trunk subversion] for this project, see the notes at http://code.google.com/p/rcoos/wiki/SubversionNotes which should apply the same for this project except that the project name is 'sqlitebot' instead of 'rcoos'

----

= Links = 

http://delicious.com/giraclarc/pogamut <br/>
http://delicious.com/giraclarc/bots <br/>

http://aigamedev.com <br/>
AI Sandbox http://aigamedev.com/open/tutorials/hard-earned-insights <br/>
Game SDK's http://aigamedev.com/search/?no_cache=1&tx_ttnews[swords]=sdk <br/>
http://www.crymod.com/thread.php?threadid=9531

Mario AI<br/>
http://julian.togelius.com/mariocompetition2009/ <br/>
http://ice-gic.ieee-cesoc.org/

http://en.wikipedia.org/wiki/Robocode

http://www.introversion.co.uk/defcon/bots/ <br/>
python API http://www.galcon.com/ <br/>
http://omegatechsys.com/Products/Bots/ <br/>
http://nerogame.org/

RTS<br/>
http://springrts.com/<br/>
http://www.boswars.org/<br/>
http://wargus.sourceforge.net/<br/>

== AI Life ==

http://nobleape.com

== Industry tools ==

http://www.xaitment.com <br/>
http://www.spirops.com <br/>
http://www.pathengine.com <br/>
http://www.ekione.com <br/>
http://www.havok.com <br/>

----

= Gotchas, Tips =

Things that took me a while to figure out:

  * In netbeans, to set the 'main project' to compile/debug/run, right click on the project of interest and choose the 'Set as main project' option
  * Set your java (and netbeans?) thread priorities in Windows to 'realtime' (and UT2004 to 'low') via the Task Manager - otherwise the bot seems to lag/hang in its environment waiting for the Java to execute.
  * When monitoring the bots via Unreal Tournament, press alt-enter for windowed version of game(instead of full screen) and ctrl-esc to move control back to the desktop
  * The format for setting the 'attributes' of the various 'ControlServer commands' listed at [https://artemis.ms.mff.cuni.cz/pogamut/tiki-index.php?page=Gamebots+API+list Gamebot API] is use of the curly brackets, e.g. like below for setting added bots skill level
{{{addbot {skill 1}{name harry}}}}
  * set the game speed - 'set speed of game' in the UT Server Control' project window to about 1/2 of the default value to better follow along the action and the bot log/thoughts as they happen.
  * netbeans jar tutorial http://www.fsl.cs.sunysb.edu/~dquigley/cse219/index.php?it=netbeans&tt=jar&pf=y
= botv1 =

For the first version bot (botv1) all I've done is hack the basic pogamut bot [http://code.google.com/p/sqlitebot/source/browse/trunk/bot1/Main.java script] to write out its location to a [http://code.google.com/p/sqlitebot/source/browse/trunk/bot1/sample.db sqlite table] when the navpoint path is broken.

The write function is called 'nasty' and the table called 'people' for no good reason.  Will rename these more appropriately later.

= Update June 22 2009 =

I've modified the bot, borrowing mostly from the 'hunter' bot example and a strafing function from the 'amis/loque' bot(many, many thanks to folks sharing their example code, which helps much with the learning/syntax curve and being able to reuse prior development).  Found it helpful to display all message events to the log and then filter ones out that I wasn't interested in.  The bot now records the map, location and timestamp when it kills or is killed(a database INSERT function) and uses one of these most recent 3 locations recorded in the last 45 game seconds to return to(a database SELECT function).

This database could be utilized to build additional summary tables(something like a heat/influence map) which could reflect further analysis/statistics processing based on the locational data.  Also interesting would be to move beyond just the bots immediate 'recent' row-based memory and begin pattern analysis of the locational data to detect generalized trends/patterns which might recur during gameplay.

The bot could also experiment with behavioral types like 'camping/sniping' at certain locations to determine the most effective spots/regions of the map or player conditions to do so.

Would also like to move into recording of pathing and enemy predicted pathing and outcomes as might be utilized in leading or flanking maneuvers.

The current sqlite table 'obs' is organized as follows

{{{
sqlite> .schema obs
CREATE TABLE obs (
  row_id integer PRIMARY KEY,
  row_entry_date text,
  map_level text,
  map_id int,
  navpoint_id int,
  location text,
  unreal_id text,
  event_location text,
  event_time real,
  event_weight real);

sqlite> select * from obs;
1|2009-06-22 12:13:06|DM-Flux2|234|180|-1226.0,-1258.0,-319.99|DM-Flux2.PathNode
16|-255.48,1193.43,-315.15|1225.19|1.0
2|2009-06-22 12:13:15|DM-Flux2|234|180|-1226.0,-1258.0,-319.99|DM-Flux2.PathNode
16|-286.4,1357.37,-296.91|1234.79|1.0
3|2009-06-22 12:13:20|DM-Flux2|234|180|-1226.0,-1258.0,-319.99|DM-Flux2.PathNode
16|-29.54,1288.36,-296.94|1239.97|1.0
}}}

== Issues ==

When the bot is 'hit' (receives a BOT_DAMAGED message), the hit message stays in memory for a while causing the bot to focus on reacting by turning for seconds longer than is necessary after the event.  To get around this, I tried adding some code to get the bot to only pay attention to hits within a certain narrower time window by keeping track of the hit time/gametime and subsequent requests.

= Bot2 =

[Bot2]






  