#summary sqliteBot homepage

see also [DevelopmentIdeas]

online presentation http://docs.google.com/present/view?id=dg2bz3n6_51dh2xbpcj <br/>
youtube http://www.youtube.com/watch?v=XWkXcTIPkpM

<wiki:toc max_depth="6">

= Introduction =

Many gaming AI's utilize behavioral decision trees, few incorporate locational/situational memory as logged say via a lightweight relational database like sqlite

This is an open source project which is trying to utilize a [http://sqlite.org sqlite] database to store gaming bot location and situational awareness to help better adapt gaming AI(Artificial Intelligence) and behaviors for games.

The project is starting utilizing the [http://artemis.ms.mff.cuni.cz/pogamut/tiki-index.php Pogamut] Java/NetBeans based project code.  This bot was also selected as a finalist in the [http://www.botprize.org/teams.html 2009 botprize contest] with finals being held in September 2009.

My(jeremy.cothran@gmail.com) development background is more with Perl so I'll be learning some Java and NetBeans as I go.  I've played with Unrealscript (similar to Java) in the past and familiar with some of the Unreal Tournament 2004 bot functions but will be learning more about that also as I go.

The initial goals of the project are:

  # Java - figure out how to properly break my files up so functions and variables are scoped properly
  # begin modifying bot behavior in interesting ways based on sqlite database lookups(locational/situational memory)

Initially I'm looking for help with the above two goals - writing Java classes/functions/packages appropriately split up across files in the project - figuring some interesting behaviors to tackle - and being familiar enough with the standing bot functions to leverage those without rewriting them.

The initial sqlite table would be structured something like:

{{{
CREATE TABLE obs_type (
    row_id integer PRIMARY KEY,
    row_entry_date text,
    map_id int,
    location text,
    status int
);
}}}

with *location* reflecting the bots map(*map_id*) location when a specified *status* (made a kill, was killed,etc) at a specified time(*row_entry_date*).

Tracking those things initially should allow a bot to begin selecting better and worse map locations for optimal scoring or begin time-based tactics or behaviors relating to location and predicted location of opponents.

= Easy install (jar file) =

Just download/unzip this [http://sqlitebot.googlecode.com/files/sqlitebot.zip zip file] to  'c:\sqlitebot' folder(includes necessary .jar and \lib) and run the following command. *The sqlite dbpath uses an absolute path of c:\sqlitebot\sample.db' so the sample.db file must live there for the script to work.* Bot shows up using bot launcher as 'Player_Jeremy' for now.

{{{java.exe -jar c:\sqlitebot\sqlitebot.jar}}}

= Installing sqlite driver = 

To get going with sqlite and java I utilized the .jar at http://www.zentus.com/sqlitejdbc/ , [http://sqlitebot.googlecode.com/files/sqlitejdbc-v056.jar .jar file here] although the connection was refused by the program until I added the .jar file to both the netbeans classpath and the location C:\Program Files\Java\jre6\lib\ext\sqlitejdbc-v056.jar (see http://www.newsvoter.com/blog/TechNotes/java-lang-ClassNotFoundException--org-sqlite-JDBC.html )

I'd like to try the Xerial sqlite .jar http://www.xerial.org/trac/Xerial/wiki/SQLiteJDBC as it should be faster executing, but the zentus seems to work for the time being.

To establish the 'sqlite' driver in the netbeans IDE, goto Window->Services, then from the pop-up window select Databases->Drivers, then right click on Drivers to add a 'New Driver' and on the pop-up after that click the 'Add' button and path to the location of the sqlite jar file (for me this is C:\Program Files\Java\jre6\lib\ext\sqlitejdbc-v056.jar )

Then click the 'Find' button for 'Driver Class' which should populate the field with 'org.sqlite.JDBC'

For the driver 'Name' field enter 'sqlite' and *be sure it is all lower case and spelled the same* for it to work with the existing code example.  If the name/case is different than 'sqlite' you may need to correct it in your *project.properties file* to get it to stop looking at the wrong/bad example for the sqlite driver.

To add the sqlite driver to the netbeans libraries, from the netbeans IDE menu choose Tools->Libraries  On the pop-up window under 'Class Libraries' choose 'New Library'and on the subsequent pop-up name the library 'sqlite' (all lower case).  Then on the following options use the 'Add JAR/Folder' button to navigate to the sqlite jar file (path is C:\Program Files\Java\jre6\lib\ext\sqlitejdbc-v056.jar )

To add the sqlite driver to the project library, under the Project->Libraries folder, choose 'Add Library' and choose the sqlite library.

== Working with sql, sqlite database ==

Download the sqlite3 windows executable .exe (in a [http://www.sqlite.org/sqlite-3_6_15.zip zip file]) from the [http://www.sqlite.org/download.html sqlite download page].

My current path to the database is 
{{{c:\progra~1\pogamu~1\PogamutPlatform\projects\AdvancedBot\src\advancedbot\sample.db}}}

To open this database and get a sqlite command prompt I issue the following command from a command window.

{{{c:\Documents and Settings\logan\Desktop>sqlite3 c:\progra~1\pogamu~1\PogamutPlatform\projects\AdvancedBot\src\advancedbot\sample.db}}}

Notice also that the above database path is required or should be changed in the java functions which access the database(Main.java).

== Basic SQL commands ==

From the sqlite command prompt, to see a list of tables<br/>
{{{.tables}}}

The only table on the database is 'obs', to see the schema<br/>
{{{.schema obs}}}

To see a listing of rows on the table<br/>
{{{select * from obs;}}}

To certain rows on the table<br/>
{{{delete from obs where row_id > 3;}}}

To delete all rows from the table<br/>
{{{delete from obs;}}}

----

= google group discussion =

http://groups.google.com/group/sqlitebot

= Subversion =

For notes on using [http://code.google.com/p/sqlitebot/source/browse/#svn/trunk subversion] for this project, see the notes at http://code.google.com/p/rcoos/wiki/SubversionNotes which should apply the same for this project except that the project name is 'sqlitebot' instead of 'rcoos'

----

= Links = 

http://delicious.com/giraclarc/pogamut <br/>
http://delicious.com/giraclarc/bots <br/>
http://aigamedev.com

----

== Gotchas, Tips ==

Things that took me a while to figure out:

  * In netbeans, to set the 'main project' to compile/debug/run, right click on the project of interest and choose the 'Set as main project' option
  * Set your java (and netbeans?) thread priorities in Windows to 'realtime' (and UT2004 to 'low') via the Task Manager - otherwise the bot seems to lag/hang in its environment waiting for the Java to execute.
  * When monitoring the bots via Unreal Tournament, press alt-enter for windowed version of game(instead of full screen) and ctrl-esc to move control back to the desktop
  * The format for setting the 'attributes' of the various 'ControlServer commands' listed at [https://artemis.ms.mff.cuni.cz/pogamut/tiki-index.php?page=Gamebots+API+list Gamebot API] is use of the curly brackets, e.g. like below for setting added bots skill level
{{{addbot {skill 1}{name harry}}}}
  * set the game speed - 'set speed of game' in the UT Server Control' project window to about 1/2 of the default value to better follow along the action and the bot log/thoughts as they happen.
  * netbeans jar tutorial http://www.fsl.cs.sunysb.edu/~dquigley/cse219/index.php?it=netbeans&tt=jar&pf=y
= botv1 =

For the first version bot (botv1) all I've done is hack the basic pogamut bot [http://code.google.com/p/sqlitebot/source/browse/trunk/bot1/Main.java script] to write out its location to a [http://code.google.com/p/sqlitebot/source/browse/trunk/bot1/sample.db sqlite table] when the navpoint path is broken.

The write function is called 'nasty' and the table called 'people' for no good reason.  Will rename these more appropriately later.

== Update June 22 2009 ==

I've modified the bot, borrowing mostly from the 'hunter' bot example and a strafing function from the 'amis/loque' bot(many, many thanks to folks sharing their example code, which helps much with the learning/syntax curve and being able to reuse prior development).  Found it helpful to display all message events to the log and then filter ones out that I wasn't interested in.  The bot now records the map, location and timestamp when it kills or is killed(a database INSERT function) and uses one of these most recent 3 locations recorded in the last 45 game seconds to return to(a database SELECT function).

This database could be utilized to build additional summary tables(something like a heat/influence map) which could reflect further analysis/statistics processing based on the locational data.  Also interesting would be to move beyond just the bots immediate 'recent' row-based memory and begin pattern analysis of the locational data to detect generalized trends/patterns which might recur during gameplay.

The bot could also experiment with behavioral types like 'camping/sniping' at certain locations to determine the most effective spots/regions of the map or player conditions to do so.

Would also like to move into recording of pathing and enemy predicted pathing and outcomes as might be utilized in leading or flanking maneuvers.

The current sqlite table 'obs' is organized as follows

{{{
sqlite> .schema obs
CREATE TABLE obs (
  row_id integer PRIMARY KEY,
  row_entry_date text,
  map_level text,
  map_id int,
  navpoint_id int,
  location text,
  unreal_id text,
  event_location text,
  event_time real,
  event_weight real);

sqlite> select * from obs;
1|2009-06-22 12:13:06|DM-Flux2|234|180|-1226.0,-1258.0,-319.99|DM-Flux2.PathNode
16|-255.48,1193.43,-315.15|1225.19|1.0
2|2009-06-22 12:13:15|DM-Flux2|234|180|-1226.0,-1258.0,-319.99|DM-Flux2.PathNode
16|-286.4,1357.37,-296.91|1234.79|1.0
3|2009-06-22 12:13:20|DM-Flux2|234|180|-1226.0,-1258.0,-319.99|DM-Flux2.PathNode
16|-29.54,1288.36,-296.94|1239.97|1.0
}}}

=== Issues ===

When the bot is 'hit' (receives a BOT_DAMAGED message), the hit message stays in memory for a while causing the bot to focus on reacting by turning for seconds longer than is necessary after the event.  To get around this, I tried adding some code to get the bot to only pay attention to hits within a certain narrower time window by keeping track of the hit time/gametime and subsequent requests.

= Bot2 =

[Bot2]

= additional links = 




  