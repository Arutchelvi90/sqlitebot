#summary tips on compiling sqlite for Visual C++

This is a summary of steps that I went through to compile the sqlite3.lib static library and some sample C++ code which utilizes that library to connect, write and query from a sample sqlite database.

This was done using the free Visual C++ 2008 Express edition IDE from Microsoft.

First download the latest C source code zip [http://www.sqlite.org/sqlite-amalgamation-3_6_22.zip sqlite-amalgamation-3_6_22.zip] from http://www.sqlite.org/download.html

<wiki:toc max_depth="6">
----
= Create static library sqlite.lib =

As a shortcut, I've included a link to the sqlite.lib that I created on my Windows XP machine [http://sqlitebot.googlecode.com/files/sqlite3.lib here] - probably better to compile the library on your system using the below steps as it may or may not work depending on the system.

Start a new project where the application type will be a static library and uncheck the precompiled headers option.

http://sqlitebot.googlecode.com/files/sqlite2.jpg

http://sqlitebot.googlecode.com/files/sqlite3.jpg

Add the .c source file to the 'Source Files' of the project and the .h files to the 'Header Files' of the project and compile a 'Release' version of the sqlite.lib file

http://sqlitebot.googlecode.com/files/sqlite4.jpg 

----
= Sample project and code =

Start a new project (the below was done as a Win32 console application) which includes in the project folder sqlite.h and sqlite.lib.  In the 'Header Files' include sqlite.h and reference the sqlite.lib file as shown below

http://sqlitebot.googlecode.com/files/sqlite1.jpg 

The sample sqlite database referenced in the example code can be downloaded at http://sqlitebot.googlecode.com/files/sample.db and assumes the filepath {{{C:\sqlitebot\sample.db}}} The schema for this database is shown at http://code.google.com/p/sqlitebot/wiki/SqlitebotSchema and that webpage also contains further examples of SQL usage(SELECT,INSERT,UPDATE,DELETE sql statements) with this schema

The following [http://www.linuxjournal.com/content/accessing-sqlite-c article] provided the initial examples used in the below code

Include files
{{{
#include <stdio.h>
#include "sqlite3.h"
}}}

== Establishing database connection ==
{{{
int _tmain(int argc, _TCHAR* argv[])
{
sqlite3 *db;

sqlite3_stmt    *res;
int             rec_count = 0;
const char      *errMSG;
const char      *tail;

int error = sqlite3_open("C:\\sqlitebot\\sample.db", &db);
if (error)
    {
    fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
    }
}}}

== SELECT - preparing the read/query and processing the resultset ==
The following sample code reads all table 'bot' records and displays the first 4 record columns from the database resultset.
{{{
error = sqlite3_prepare_v2(db,
        "SELECT * FROM bot",
        1000, &res, &tail);

if (error != SQLITE_OK)
    {
    puts("We did not get any data!");
    return 0;
    }

puts("==========================");

while (sqlite3_step(res) == SQLITE_ROW)
    {
    printf("%d|", sqlite3_column_text(res, 0));
    printf("%s|", sqlite3_column_text(res, 1));
    printf("%s|", sqlite3_column_text(res, 2));
    printf("%d\n", sqlite3_column_int(res, 3));

    rec_count++;
    }

puts("==========================");
printf("We received %d records.\n", rec_count);
}}}

== INSERT, UPDATE, DELETE == 
{{{
error = sqlite3_exec(db,
    "INSERT INTO command(status,level,priority,squad_name,command,target) VALUES (0,2,1.0,\'gonzo.roam\',\'hunt\',\'jerr\')",
    0, 0, 0);

error = sqlite3_exec(db,
    "UPDATE command SET status=0, priority=1.0 WHERE row_id=5",
    0, 0, 0);

error = sqlite3_exec(db,
    "DELETE FROM command WHERE target = \'jerr\' AND priority > 1.0",
    0, 0, 0);
}}}

== Closing the statement handler and database connection ==
{{{
sqlite3_finalize(res);
sqlite3_close (db); 

return 0;
}
}}}

== Transactions ==

Note that sqlite database supports [http://www.sqlite.org/lang_transaction.html *transactions*] which is a much faster way to batch process multiple SQL INSERT or UPDATE statements.  The outline of the SQL commands for this is:

{{{
BEGIN TRANSACTION or BEGIN

some set of SQL statements or statement in a loop

END TRANSACTION or COMMIT
}}}

If any error occurs with the transaction, the set/batch of statements will *not* be committed to the database - the statements will be rolled back(ROLLBACK) to the previous BEGIN TRANSACTION or COMMIT statement.